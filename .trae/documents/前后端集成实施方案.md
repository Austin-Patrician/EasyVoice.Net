# 豆包实时语音对话前后端集成实施方案

## 1. 实施概述

本方案基于现有的 `DouBaoRealTimeClient.cs` 和 `DoubaoAudioManager.cs` 实现，通过创建 SignalR Hub 将后端豆包实时语音功能与前端 React 页面集成，实现完整的 Web 端实时语音对话功能。

## 2. 后端实施方案

### 2.1 创建 SignalR Hub

在 `EasyVoice.RealtimeDialog/Hubs/` 目录下创建 `RealtimeDialogHub.cs`：

```csharp
using Microsoft.AspNetCore.SignalR;
using Microsoft.Extensions.Caching.Memory;
using System.Collections.Concurrent;

namespace EasyVoice.RealtimeDialog.Hubs
{
    public class RealtimeDialogHub : Hub
    {
        private readonly IMemoryCache _cache;
        private readonly ILogger<RealtimeDialogHub> _logger;
        private static readonly ConcurrentDictionary<string, SessionInfo> _sessions = new();

        public RealtimeDialogHub(IMemoryCache cache, ILogger<RealtimeDialogHub> logger)
        {
            _cache = cache;
            _logger = logger;
        }

        public override async Task OnConnectedAsync()
        {
            _logger.LogInformation($"客户端连接: {Context.ConnectionId}");
            await base.OnConnectedAsync();
        }

        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            _logger.LogInformation($"客户端断开: {Context.ConnectionId}");
            // 清理该连接的所有会话
            await CleanupConnectionSessions();
            await base.OnDisconnectedAsync(exception);
        }

        /// <summary>
        /// 创建对话会话
        /// </summary>
        public async Task<string> CreateSession(SessionConfig config)
        {
            try
            {
                var sessionId = Guid.NewGuid().ToString();
                var sessionInfo = new SessionInfo
                {
                    SessionId = sessionId,
                    Config = config,
                    ConnectionId = Context.ConnectionId
                };

                _sessions.TryAdd(sessionId, sessionInfo);
                _cache.Set($"session_{sessionId}", sessionInfo, TimeSpan.FromHours(1));

                await Clients.Caller.SendAsync("OnSessionStarted", sessionId);
                _logger.LogInformation($"会话创建成功: {sessionId}");
                
                return sessionId;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "创建会话失败");
                await Clients.Caller.SendAsync("OnError", $"创建会话失败: {ex.Message}");
                return string.Empty;
            }
        }

        /// <summary>
        /// 结束对话会话
        /// </summary>
        public async Task EndSession(string sessionId)
        {
            try
            {
                if (_sessions.TryRemove(sessionId, out var sessionInfo))
                {
                    // 停止音频管理器
                    sessionInfo.AudioManager?.Dispose();
                    _cache.Remove($"session_{sessionId}");
                    
                    await Clients.Caller.SendAsync("OnSessionEnded", sessionId);
                    _logger.LogInformation($"会话结束: {sessionId}");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"结束会话失败: {sessionId}");
                await Clients.Caller.SendAsync("OnError", $"结束会话失败: {ex.Message}");
            }
        }

        /// <summary>
        /// 设置音频配置
        /// </summary>
        public async Task SetAudioConfig(AudioConfig config)
        {
            // 存储音频配置到连接上下文
            Context.Items["AudioConfig"] = config;
            await Task.CompletedTask;
        }

        /// <summary>
        /// 开始录制
        /// </summary>
        public async Task<bool> StartRecording()
        {
            try
            {
                await Clients.Caller.SendAsync("OnRecordingStarted", Context.ConnectionId);
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "开始录制失败");
                await Clients.Caller.SendAsync("OnAudioError", $"开始录制失败: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 停止录制
        /// </summary>
        public async Task StopRecording()
        {
            try
            {
                await Clients.Caller.SendAsync("OnRecordingStopped", Context.ConnectionId);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "停止录制失败");
                await Clients.Caller.SendAsync("OnAudioError", $"停止录制失败: {ex.Message}");
            }
        }

        /// <summary>
        /// 发送音频数据
        /// </summary>
        public async Task SendAudio(string sessionId, byte[] audioData, bool isEnd)
        {
            try
            {
                if (!_sessions.TryGetValue(sessionId, out var sessionInfo))
                {
                    await Clients.Caller.SendAsync("OnError", "会话不存在");
                    return;
                }

                // 初始化音频管理器（如果尚未初始化）
                if (sessionInfo.AudioManager == null)
                {
                    await InitializeAudioManager(sessionInfo);
                }

                // 发送音频数据到豆包
                if (sessionInfo.AudioManager != null)
                {
                    await sessionInfo.AudioManager.SendAudioAsync(audioData);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"发送音频失败: {sessionId}");
                await Clients.Caller.SendAsync("OnError", $"发送音频失败: {ex.Message}");
            }
        }

        /// <summary>
        /// 发送ChatTTS文本
        /// </summary>
        public async Task<bool> SendChatTtsText(string sessionId, string text)
        {
            try
            {
                if (!_sessions.TryGetValue(sessionId, out var sessionInfo))
                {
                    await Clients.Caller.SendAsync("OnError", "会话不存在");
                    return false;
                }

                if (sessionInfo.AudioManager != null)
                {
                    await sessionInfo.AudioManager.SendChatTtsTextAsync(text);
                    return true;
                }
                
                return false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"发送ChatTTS文本失败: {sessionId}");
                await Clients.Caller.SendAsync("OnError", $"发送ChatTTS文本失败: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 初始化音频管理器
        /// </summary>
        private async Task InitializeAudioManager(SessionInfo sessionInfo)
        {
            try
            {
                // 构建WebSocket配置
                var wsConfig = new Dictionary<string, object>
                {
                    ["base_url"] = "wss://openspeech.bytedance.com/api/v1/ws",
                    ["headers"] = new Dictionary<string, string>
                    {
                        ["X-Api-App-ID"] = sessionInfo.Config.AppId,
                        ["X-Api-Access-Key"] = sessionInfo.Config.AccessKey
                    }
                };

                // 创建音频配置
                var inputConfig = new AudioConfigData
                {
                    Format = sessionInfo.Config.AudioConfig.Format,
                    BitSize = sessionInfo.Config.AudioConfig.BitDepth,
                    Channels = sessionInfo.Config.AudioConfig.Channels,
                    SampleRate = sessionInfo.Config.AudioConfig.SampleRate,
                    Chunk = sessionInfo.Config.AudioConfig.ChunkSize
                };

                var outputConfig = new AudioConfigData
                {
                    Format = "pcm",
                    BitSize = 16,
                    Channels = 1,
                    SampleRate = 24000,
                    Chunk = 4800
                };

                // 创建音频管理器
                sessionInfo.AudioManager = new DoubaoAudioManager(wsConfig, inputConfig, outputConfig);
                
                // 设置事件处理
                sessionInfo.AudioManager.OnAudioDataReceived += async (audioData) =>
                {
                    await Clients.Client(sessionInfo.ConnectionId).SendAsync("OnTtsResponse", new { audioData });
                };

                sessionInfo.AudioManager.OnDialogEvent += async (eventType, eventData) =>
                {
                    await HandleDialogEvent(sessionInfo.ConnectionId, eventType, eventData);
                };

                // 启动音频管理器
                _ = Task.Run(async () => await sessionInfo.AudioManager.StartAsync());
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "初始化音频管理器失败");
                throw;
            }
        }

        /// <summary>
        /// 处理对话事件
        /// </summary>
        private async Task HandleDialogEvent(string connectionId, string eventType, object eventData)
        {
            switch (eventType)
            {
                case "ASR_INFO":
                    await Clients.Client(connectionId).SendAsync("OnAsrInfo", eventData);
                    break;
                case "ASR_RESPONSE":
                    await Clients.Client(connectionId).SendAsync("OnAsrResponse", eventData);
                    break;
                case "ASR_ENDED":
                    await Clients.Client(connectionId).SendAsync("OnAsrEnded", eventData);
                    break;
                default:
                    _logger.LogWarning($"未知事件类型: {eventType}");
                    break;
            }
        }

        /// <summary>
        /// 清理连接的所有会话
        /// </summary>
        private async Task CleanupConnectionSessions()
        {
            var sessionsToRemove = _sessions.Where(kvp => kvp.Value.ConnectionId == Context.ConnectionId).ToList();
            
            foreach (var session in sessionsToRemove)
            {
                if (_sessions.TryRemove(session.Key, out var sessionInfo))
                {
                    sessionInfo.AudioManager?.Dispose();
                    _cache.Remove($"session_{session.Key}");
                }
            }
            
            await Task.CompletedTask;
        }
    }
}
```

### 2.2 扩展 DoubaoAudioManager

需要为 `DoubaoAudioManager` 添加事件支持和新的方法：

```csharp
// 在 DoubaoAudioManager 类中添加事件
public event Func<byte[], Task>? OnAudioDataReceived;
public event Func<string, object, Task>? OnDialogEvent;

// 添加发送音频的方法
public async Task SendAudioAsync(byte[] audioData)
{
    await _client.TaskRequestAsync(audioData, _cancellationTokenSource.Token);
}

// 添加发送ChatTTS文本的方法
public async Task SendChatTtsTextAsync(string text)
{
    _isSendingChatTtsText = true;
    await _client.ChatTtsTextAsync(
        _isUserQuerying,
        start: true,
        end: true,
        text,
        _cancellationTokenSource.Token);
}

// 修改 HandleServerResponse 方法，添加事件触发
public void HandleServerResponse(Dictionary<string, object> response)
{
    // ... 现有逻辑 ...
    
    // 触发音频数据事件
    if (messageType == "SERVER_ACK" && response.GetValueOrDefault("payload_msg") is byte[] audioData)
    {
        OnAudioDataReceived?.Invoke(audioData);
        // ... 现有逻辑 ...
    }
    
    // 触发对话事件
    if (messageType == "SERVER_FULL_RESPONSE")
    {
        if (response.TryGetValue("event", out var eventObj) && eventObj is int eventCode)
        {
            switch (eventCode)
            {
                case 450:
                    OnDialogEvent?.Invoke("ASR_INFO", response);
                    break;
                case 451:
                    OnDialogEvent?.Invoke("ASR_RESPONSE", response);
                    break;
                case 459:
                    OnDialogEvent?.Invoke("ASR_ENDED", response);
                    break;
            }
        }
    }
}
```

### 2.3 注册服务

在主项目的 `Program.cs` 中注册 SignalR 服务：

```csharp
// 添加 SignalR 服务
builder.Services.AddSignalR();
builder.Services.AddMemoryCache();

// 配置 CORS（如果需要）
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowReactApp", policy =>
    {
        policy.WithOrigins("http://localhost:3000")
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});

// 在 app 配置中
app.UseCors("AllowReactApp");
app.MapHub<RealtimeDialogHub>("/hubs/realtime-dialog");
```

## 3. 前端实施方案

### 3.1 更新前端页面

前端 `RealtimeDialog.tsx` 已经基本实现了所需功能，主要需要确保以下几点：

1. **SignalR 连接配置正确**：
```typescript
const newConnection = new HubConnectionBuilder()
  .withUrl('http://localhost:5094/hubs/realtime-dialog') // 确保端口正确
  .withAutomaticReconnect()
  .configureLogging(LogLevel.Information)
  .build();
```

2. **音频数据处理优化**：
```typescript
// 优化音频数据转换
const sendAudioChunk = async (audioBlob: Blob) => {
  if (!connection || !sessionId) {
    return;
  }
  
  try {
    const arrayBuffer = await audioBlob.arrayBuffer();
    const audioData = Array.from(new Uint8Array(arrayBuffer)); // 转换为数字数组
    
    await connection.invoke('SendAudio', sessionId, audioData, false);
  } catch (error) {
    console.error('发送音频失败:', error);
  }
};
```

3. **音频播放优化**：
```typescript
// 优化音频播放
const playAudioData = async (audioData: number[]) => {
  try {
    const audioContext = new AudioContext({ sampleRate: 24000 });
    const audioBuffer = audioContext.createBuffer(1, audioData.length, 24000);
    const channelData = audioBuffer.getChannelData(0);
    
    // 转换音频数据（假设是16位PCM）
    for (let i = 0; i < audioData.length; i++) {
      channelData[i] = audioData[i] / 32768;
    }
    
    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioContext.destination);
    source.start();
    
  } catch (error) {
    console.error('播放音频失败:', error);
    toast.error('播放音频失败');
  }
};
```

## 4. 部署和测试

### 4.1 后端启动
```bash
cd /Users/aa123456/code/net/EasyVoice.Net
dotnet run --project EasyVoice.Api
```

### 4.2 前端启动
```bash
cd /Users/aa123456/code/net/EasyVoice.Net/frontend-react
npm run dev
```

### 4.3 测试流程
1. 打开浏览器访问前端页面
2. 配置豆包 API 密钥
3. 点击连接服务器
4. 创建会话
5. 开始录制并测试语音交互
6. 验证 ASR 识别和 TTS 播放功能
7. 测试 ChatTTS 文本输入功能

## 5. 注意事项

1. **音频格式兼容性**：确保前端录制的音频格式与后端期望的格式一致
2. **错误处理**：完善各个环节的错误处理和用户提示
3. **资源清理**：确保会话结束时正确清理音频资源
4. **性能优化**：考虑音频数据的缓冲和压缩
5. **安全性**：API 密钥的安全存储和传输

通过以上实施方案，可以将现有的豆包实时语音功能完整地集成到 Web 前端，实现类似 Python 版本 `audio_manager.py` 的功能。